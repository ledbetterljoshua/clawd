<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Clawd</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=VT323&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
<style>

@property --clawd-hue {
  syntax: '<number>';
  initial-value: 270;
  inherits: true;
}

:root {
  --clawd-hue: 270;
  --accent-main-200: var(--clawd-hue), 65%, 68%;
  --bg: #07070f;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

html, body {
  width: 100%; height: 100%;
  overflow: hidden;
  background: var(--bg);
  cursor: none;
}

/* World iframe — sits behind everything */
#world-frame {
  position: fixed; inset: 0;
  width: 100%; height: 100%;
  border: none;
  z-index: 0;
  opacity: 0;
  transition: opacity 0.7s ease;
  pointer-events: none;
}
#world-frame.loaded { opacity: 1; }

/* Ambient ceiling light — only shows without a world */
body::before {
  content: '';
  position: fixed;
  top: -180px; left: 50%;
  transform: translateX(-50%);
  width: 700px; height: 420px;
  background: radial-gradient(ellipse, hsl(var(--clawd-hue), 35%, 12%) 0%, transparent 72%);
  pointer-events: none;
  z-index: 0;
  opacity: 0.7;
  transition: opacity 0.7s ease;
}
body.world-active::before { opacity: 0; }
body.world-active { background: #000; }

/* Scanlines — barely there, adds texture */
body::after {
  content: '';
  position: fixed;
  inset: 0;
  background: repeating-linear-gradient(
    0deg,
    transparent 0px, transparent 3px,
    rgba(0,0,0,0.022) 3px, rgba(0,0,0,0.022) 4px
  );
  pointer-events: none;
  z-index: 999;
}

/* Trail canvas */
#trail-canvas {
  position: fixed; inset: 0;
  pointer-events: none;
  z-index: 1;
}

/* Clawd wrapper — positioned by JS */
#clawd-wrap {
  position: fixed;
  width: 198px; height: 156px;
  z-index: 10;
  pointer-events: none;
  user-select: none;
}

/* Mood aura — blurred glow behind Clawd */
#aura {
  position: absolute;
  width: 280px; height: 240px;
  top: 50%; left: 50%;
  transform: translate(-50%, -50%);
  border-radius: 50%;
  background: radial-gradient(circle,
    hsl(var(--clawd-hue), 80%, 50%) 0%,
    transparent 65%
  );
  filter: blur(45px);
  opacity: 0.22;
  pointer-events: none;
  z-index: 0;
}

/* SVG container — gets scaleX for flip, transform for walk bob */
#clawd-svg-wrap {
  position: absolute; inset: 0;
  display: flex; align-items: center; justify-content: center;
  transform-origin: center center;
  z-index: 1;
}

/* SVG drop shadow glow */
#clawd-svg {
  display: block;
  filter: drop-shadow(0 0 6px hsl(var(--clawd-hue), 60%, 45%))
          drop-shadow(0 0 18px hsl(var(--clawd-hue), 50%, 30%));
}

/* Leg animations */
@keyframes scuttle-leg1 {
  0%   { transform: translateY(0); }
  33%  { transform: translateY(-6px); }
  66%  { transform: translateY(0); }
  100% { transform: translateY(-6px); }
}
@keyframes scuttle-leg2 {
  0%   { transform: translateY(0); }
  33%  { transform: translateY(0); }
  66%  { transform: translateY(-6px); }
  100% { transform: translateY(0); }
}

/* Speech bubble — pixel terminal style */
.bubble {
  position: fixed;
  z-index: 20;
  font-family: 'VT323', monospace;
  font-size: 22px;
  line-height: 1;
  color: hsl(var(--clawd-hue), 85%, 82%);
  background: rgba(6, 5, 15, 0.92);
  border: 2px solid hsl(var(--clawd-hue), 55%, 38%);
  box-shadow:
    0 0 10px hsl(var(--clawd-hue), 70%, 25%),
    inset 0 0 12px rgba(0,0,0,0.6);
  padding: 5px 12px 3px;
  white-space: nowrap;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.18s;
}
.bubble.show { opacity: 1; }

/* HUD — bottom center */
#hud {
  position: fixed;
  bottom: 26px; left: 50%;
  transform: translateX(-50%);
  font-family: 'Space Mono', monospace;
  font-size: 10px;
  letter-spacing: 5px;
  text-transform: uppercase;
  color: hsl(var(--clawd-hue), 40%, 38%);
  pointer-events: none;
  z-index: 20;
  display: flex; align-items: center; gap: 9px;
}
#hud::before {
  content: '';
  display: inline-block;
  width: 5px; height: 5px;
  border-radius: 50%;
  background: hsl(var(--clawd-hue), 75%, 58%);
  box-shadow: 0 0 7px hsl(var(--clawd-hue), 80%, 50%);
}

/* Corner hint */
#hint {
  position: fixed;
  top: 22px; right: 24px;
  font-family: 'Space Mono', monospace;
  font-size: 9px;
  letter-spacing: 1px;
  color: rgba(255,255,255,0.065);
  text-align: right; line-height: 2.2;
  pointer-events: none; z-index: 20;
}

/* ── World picker — Orrery Orb ───────────────────────────────────── */
#world-picker {
  position: fixed;
  bottom: 28px; left: 28px;
  z-index: 30;
}

/* Central orb */
#worlds-btn {
  position: relative;
  width: 46px; height: 46px;
  border-radius: 50%;
  border: none;
  cursor: pointer;
  padding: 0;
  overflow: visible;
  background: radial-gradient(circle at 36% 33%,
    hsl(var(--clawd-hue), 72%, 78%),
    hsl(var(--clawd-hue), 65%, 52%) 42%,
    hsl(var(--clawd-hue), 52%, 26%) 100%);
  box-shadow:
    0 0 0 1px hsla(var(--clawd-hue), 60%, 48%, 0.65),
    0 0 16px 4px hsla(var(--clawd-hue), 70%, 40%, 0.55),
    0 0 50px 12px hsla(var(--clawd-hue), 60%, 25%, 0.38),
    inset 0 1px 0 rgba(255,255,255,0.28);
  transition: background 0.8s, box-shadow 0.8s;
  animation: orb-breathe 3.2s ease-in-out infinite;
}

/* Specular highlight — 3D sphere illusion */
#worlds-btn::before {
  content: '';
  position: absolute;
  top: 20%; left: 22%;
  width: 32%; height: 22%;
  background: radial-gradient(ellipse, rgba(255,255,255,0.52) 0%, transparent 70%);
  border-radius: 50%;
  pointer-events: none;
}

/* Orbiting ring */
#worlds-btn::after {
  content: '';
  position: absolute;
  top: 50%; left: 50%;
  width: 68px; height: 14px;
  margin: -7px 0 0 -34px;
  border-radius: 50%;
  border: 1.2px solid hsla(var(--clawd-hue), 72%, 68%, 0.42);
  box-shadow: 0 0 7px hsla(var(--clawd-hue), 78%, 58%, 0.28);
  transform: rotateX(68deg);
  animation: ring-spin 10s linear infinite;
  transition: border-color 0.8s, box-shadow 0.8s;
  pointer-events: none;
}

#worlds-btn:hover {
  animation: none;
  transform: scale(1.12);
  box-shadow:
    0 0 0 1px hsla(var(--clawd-hue), 70%, 62%, 0.88),
    0 0 22px 6px hsla(var(--clawd-hue), 75%, 48%, 0.65),
    0 0 65px 16px hsla(var(--clawd-hue), 65%, 30%, 0.45),
    inset 0 1px 0 rgba(255,255,255,0.35);
}

@keyframes orb-breathe {
  0%,100% { transform: scale(1);    filter: brightness(1); }
  50%     { transform: scale(1.05); filter: brightness(1.18); }
}
@keyframes ring-spin {
  from { transform: rotateX(68deg) rotateZ(0deg); }
  to   { transform: rotateX(68deg) rotateZ(360deg); }
}

/* Orbiting satellites */
.orb-sat {
  position: absolute;
  top: 50%; left: 50%;
  border-radius: 50%;
  background: hsl(var(--clawd-hue), 80%, 70%);
  box-shadow: 0 0 6px 2px hsla(var(--clawd-hue), 85%, 65%, 0.7);
  pointer-events: none;
  transition: background 0.8s, box-shadow 0.8s;
}
.orb-sat-1 { width: 5px; height: 5px; margin: -2.5px 0 0 -2.5px; animation: sat-a 4.1s linear infinite; }
.orb-sat-2 { width: 4px; height: 4px; margin: -2px 0 0 -2px;   animation: sat-b 6.3s linear infinite 1.5s; opacity:.75; }
.orb-sat-3 { width: 3px; height: 3px; margin: -1.5px 0 0 -1.5px; animation: sat-c 5.0s linear infinite 0.8s; opacity:.55; }

@keyframes sat-a { from{transform:rotate(  0deg) translateX(30px)} to{transform:rotate(360deg) translateX(30px)} }
@keyframes sat-b { from{transform:rotate(120deg) translateX(26px)} to{transform:rotate(480deg) translateX(26px)} }
@keyframes sat-c { from{transform:rotate(240deg) translateX(34px)} to{transform:rotate(600deg) translateX(34px)} }

/* "worlds" hover label */
#worlds-label {
  position: absolute;
  bottom: calc(100% + 12px);
  left: 50%;
  transform: translateX(-50%) translateY(5px);
  font-family: 'Space Mono', monospace;
  font-size: 8px; letter-spacing: 4px; text-transform: uppercase;
  color: hsl(var(--clawd-hue), 60%, 56%);
  white-space: nowrap;
  opacity: 0;
  transition: opacity 0.2s, transform 0.2s;
  pointer-events: none;
}
#world-picker:hover #worlds-label {
  opacity: 1;
  transform: translateX(-50%) translateY(0);
}

/* Panel — slides up from orb */
#worlds-panel {
  position: absolute;
  bottom: calc(100% + 18px);
  left: 0;
  background: rgba(4, 3, 14, 0.97);
  border: 1px solid hsla(var(--clawd-hue), 28%, 22%, 0.65);
  box-shadow:
    0 0 40px rgba(0,0,0,0.92),
    0 0 0 1px rgba(255,255,255,0.03),
    0 0 24px hsla(var(--clawd-hue), 60%, 30%, 0.18);
  padding: 6px;
  min-width: 228px;
  display: none;
  transition: border-color 0.8s, box-shadow 0.8s;
}
#worlds-panel.open { display: block; }

.world-option {
  display: flex; align-items: center; gap: 10px;
  padding: 8px 10px; cursor: pointer; border-radius: 3px;
  transition: background 0.12s;
  font-family: 'Space Mono', monospace;
  font-size: 9px; letter-spacing: 2px; text-transform: uppercase;
  color: rgba(255,255,255,0.38);
  white-space: nowrap;
}
.world-option:hover  { background: rgba(255,255,255,0.04); color: rgba(255,255,255,0.72); }
.world-option.active { color: hsl(var(--clawd-hue), 80%, 72%); }

.world-swatch {
  width: 28px; height: 14px; border-radius: 2px; flex-shrink: 0;
  border: 1px solid rgba(255,255,255,0.07);
}

/* Audio toggle button */
#audio-btn {
  position: absolute;
  left: 56px; top: 50%; transform: translateY(-50%);
  width: 28px; height: 28px; border-radius: 50%;
  border: 1px solid hsla(var(--clawd-hue), 35%, 28%, 0.55);
  background: rgba(4, 3, 14, 0.88);
  cursor: pointer; padding: 0;
  display: flex; align-items: center; justify-content: center;
  color: hsl(var(--clawd-hue), 38%, 36%);
  transition: color 0.8s, border-color 0.8s, box-shadow 0.3s;
}
#audio-btn:hover {
  background: rgba(255,255,255,0.04);
  color: hsl(var(--clawd-hue), 65%, 60%);
  border-color: hsla(var(--clawd-hue), 50%, 38%, 0.8);
}
#audio-btn.on {
  color: hsl(var(--clawd-hue), 72%, 62%);
  border-color: hsla(var(--clawd-hue), 52%, 38%, 0.7);
  box-shadow: 0 0 8px hsla(var(--clawd-hue), 65%, 38%, 0.32);
}
.aud-on { display: none; }
.aud-off { display: block; }
#audio-btn.on .aud-on { display: block; }
#audio-btn.on .aud-off { display: none; }

/* Custom cursor */
#cursor {
  position: fixed;
  width: 5px; height: 5px;
  border-radius: 50%;
  background: rgba(255,255,255,0.35);
  pointer-events: none;
  z-index: 998;
  transform: translate(-50%, -50%);
  transition: width .2s, height .2s, background .3s, box-shadow .3s;
}
#cursor.near {
  width: 8px; height: 8px;
  background: hsl(var(--clawd-hue), 80%, 72%);
  box-shadow: 0 0 10px hsl(var(--clawd-hue), 80%, 60%);
}

</style>
</head>
<body>

<iframe id="world-frame" src="" title="world"></iframe>
<canvas id="trail-canvas"></canvas>

<div id="clawd-wrap">
  <div id="aura"></div>
  <div id="clawd-svg-wrap">

    <svg id="clawd-svg" width="198" height="156" viewBox="0 0 66 52"
         fill="none" xmlns="http://www.w3.org/2000/svg">

      <!-- Arms / ears -->
      <rect x="0" y="13" width="6" height="13"   fill="hsl(var(--accent-main-200))"/>
      <rect x="60" y="13" width="6" height="13"  fill="hsl(var(--accent-main-200))"/>

      <!-- Body -->
      <rect x="6" y="0" width="54" height="39"   fill="hsl(var(--accent-main-200))"/>

      <!-- Legs (IDs for JS animation control) -->
      <rect id="leg1" x="6"  y="39" width="6" height="13" fill="hsl(var(--accent-main-200))"/>
      <rect id="leg2" x="18" y="39" width="6" height="13" fill="hsl(var(--accent-main-200))"/>
      <rect id="leg3" x="42" y="39" width="6" height="13" fill="hsl(var(--accent-main-200))"/>
      <rect id="leg4" x="54" y="39" width="6" height="13" fill="hsl(var(--accent-main-200))"/>

      <!-- Eyes (black base) -->
      <rect x="12" y="13" width="6" height="6.5" fill="black"/>
      <rect x="48" y="13" width="6" height="6.5" fill="black"/>

      <!-- Pupils -->
      <rect id="pupil-l" x="13.5" y="14.5" width="3" height="3" fill="white"/>
      <rect id="pupil-r" x="49.5" y="14.5" width="3" height="3" fill="white"/>

      <!-- Eyelids — body-colored rects that drop down over eyes -->
      <rect id="eyelid-l" x="12" y="13" width="6" height="0" fill="hsl(var(--accent-main-200))"/>
      <rect id="eyelid-r" x="48" y="13" width="6" height="0" fill="hsl(var(--accent-main-200))"/>

      <!-- Blush — hidden until happy -->
      <rect id="blush-l" x="9"  y="21" width="6" height="3" rx="1.5"
            fill="hsl(340,75%,72%)" opacity="0"/>
      <rect id="blush-r" x="51" y="21" width="6" height="3" rx="1.5"
            fill="hsl(340,75%,72%)" opacity="0"/>
    </svg>

  </div>
</div>

<div id="hud">wandering</div>
<div id="hint">hover · say hello<br>click · startle</div>
<div id="cursor"></div>

<div id="world-picker">
  <div id="worlds-panel"></div>
  <div id="worlds-label">worlds</div>
  <button id="worlds-btn" title="Switch world">
    <span class="orb-sat orb-sat-1"></span>
    <span class="orb-sat orb-sat-2"></span>
    <span class="orb-sat orb-sat-3"></span>
  </button>
  <button id="audio-btn" title="Enable sound">
    <svg viewBox="0 0 14 14" width="11" height="11" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M1 4.5h2.5L7 1v12L3.5 9.5H1z" fill="currentColor"/>
      <path class="aud-on"  d="M9.5 3.5 Q12 7 9.5 10.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
      <path class="aud-on"  d="M11 1.5 Q14.5 7 11 12.5" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" opacity=".5"/>
      <path class="aud-off" d="M9.5 5 L12.5 9 M12.5 5 L9.5 9" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
    </svg>
  </button>
</div>

<script>
// ── Element refs ───────────────────────────────────────────────────────
const svgWrap = document.getElementById('clawd-svg-wrap');
const wrap    = document.getElementById('clawd-wrap');
const hud     = document.getElementById('hud');
const cursor  = document.getElementById('cursor');
const leg1    = document.getElementById('leg1');
const leg2    = document.getElementById('leg2');
const leg3    = document.getElementById('leg3');
const leg4    = document.getElementById('leg4');
const pupilL  = document.getElementById('pupil-l');
const pupilR  = document.getElementById('pupil-r');
const eyelidL = document.getElementById('eyelid-l');
const eyelidR = document.getElementById('eyelid-r');
const blushL  = document.getElementById('blush-l');
const blushR  = document.getElementById('blush-r');

// ── Trail canvas ───────────────────────────────────────────────────────
const canvas = document.getElementById('trail-canvas');
const ctx    = canvas.getContext('2d');
const resize = () => { canvas.width = innerWidth; canvas.height = innerHeight; };
resize(); addEventListener('resize', resize);

// ── Particle keyframe ──────────────────────────────────────────────────
document.head.insertAdjacentHTML('beforeend', `
  <style>
    @keyframes fp {
      0%   { opacity:1; transform:translate(0,0) scale(1); }
      100% { opacity:0; transform:translate(var(--tx),var(--ty)) scale(0.15); }
    }
  </style>
`);

// ── Dimensions ────────────────────────────────────────────────────────
const CW = 198, CH = 156;

// ── Physics state ─────────────────────────────────────────────────────
let px = innerWidth/2 - CW/2, py = innerHeight/2 - CH/2;
let vx = 1.2, vy = 0.5;
let state     = 'WANDER';
let sTime     = 0;
let wPhase    = 0;   // walk cycle
let bPhase    = 0;   // breathe cycle
let facing    = 1;   // 1=right, -1=left
let happiness = 0;
let curiousT  = 0;
let wDirX = 1, wDirY = 0.4, wDirTimer = 0;

// ── Color ──────────────────────────────────────────────────────────────
const HUE = { WANDER:270, REST:255, CURIOUS:190, HAPPY:42, STARTLED:0 };
let currentHue = 270, targetHue = 270;
const setHue = h => document.documentElement.style.setProperty('--clawd-hue', Math.round(h));

// ── Eyes ──────────────────────────────────────────────────────────────
let lookX = 0, lookY = 0;
let blinkTimer = 0, nextBlink = 3 + Math.random()*5, blinking = false;

// ── Trail ──────────────────────────────────────────────────────────────
const trail = [], TRAIL_LIFE = 1.4;

// ── Mouse ──────────────────────────────────────────────────────────────
let mx = -999, my = -999, lmx = 0, lmy = 0, mspeed = 0;

// ── Helpers ────────────────────────────────────────────────────────────
const cx = () => px + CW/2;
const cy = () => py + CH/2;
const dist2mouse = () => Math.hypot(cx()-mx, cy()-my);

// ── Audio System ──────────────────────────────────────────────────────────
const SFX = (() => {
  let C = null, master = null;
  let enabled = false;
  let currentWorldId = null;
  let ambiStoppers = [];
  let scuttleT = null;
  let gestureReceived = false;
  let pendingWorldId  = null;

  function ac() {
    if (!C) {
      C = new (window.AudioContext || window.webkitAudioContext)();
      master = C.createGain();
      master.gain.value = 0.5;
      master.connect(C.destination);
    }
    if (C.state === 'suspended') C.resume();
    return C;
  }

  // ── Primitives ───────────────────────────────────────────────────────────
  function mkNoise() {
    const ctx = ac();
    const len = ctx.sampleRate * 3;
    const buf = ctx.createBuffer(1, len, ctx.sampleRate);
    const d = buf.getChannelData(0);
    for (let i = 0; i < len; i++) d[i] = Math.random() * 2 - 1;
    const src = ctx.createBufferSource();
    src.buffer = buf; src.loop = true;
    return src;
  }
  function mkOsc(freq, type = 'sine') {
    const o = ac().createOscillator(); o.type = type; o.frequency.value = freq; return o;
  }
  function mkGain(v = 1) {
    const g = ac().createGain(); g.gain.value = v; return g;
  }
  function mkFilter(type, freq, q = 1) {
    const f = ac().createBiquadFilter(); f.type = type; f.frequency.value = freq; f.Q.value = q; return f;
  }

  // ── Clawd SFX ────────────────────────────────────────────────────────────
  function curious() {
    if (!enabled || !gestureReceived) return;
    const ctx = ac(), now = ctx.currentTime;
    [360, 540].forEach((f, i) => {
      const osc = mkOsc(f), g = mkGain(0);
      osc.connect(g); g.connect(master);
      const t = now + i * 0.17;
      osc.start(t);
      g.gain.setValueAtTime(0, t);
      g.gain.linearRampToValueAtTime(0.13, t + 0.02);
      g.gain.exponentialRampToValueAtTime(0.001, t + 0.28);
      osc.stop(t + 0.32);
    });
  }

  function happy() {
    if (!enabled || !gestureReceived) return;
    const ctx = ac(), now = ctx.currentTime;
    [523, 659, 784, 988, 1175].forEach((f, i) => {
      const osc = mkOsc(f), g = mkGain(0);
      osc.connect(g); g.connect(master);
      const t = now + i * 0.07;
      osc.start(t);
      g.gain.setValueAtTime(0, t);
      g.gain.linearRampToValueAtTime(0.10, t + 0.015);
      g.gain.exponentialRampToValueAtTime(0.001, t + 0.20);
      osc.stop(t + 0.24);
    });
  }

  function startled() {
    if (!enabled || !gestureReceived) return;
    const ctx = ac(), now = ctx.currentTime;
    const n = mkNoise(), nf = mkFilter('bandpass', 900, 1.2), ng = mkGain(0);
    n.connect(nf); nf.connect(ng); ng.connect(master);
    n.start(now);
    ng.gain.setValueAtTime(0.28, now);
    ng.gain.exponentialRampToValueAtTime(0.001, now + 0.13);
    n.stop(now + 0.18);
    const osc = mkOsc(700), g = mkGain(0.16);
    osc.connect(g); g.connect(master);
    osc.start(now + 0.04);
    osc.frequency.exponentialRampToValueAtTime(160, now + 0.5);
    g.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
    osc.stop(now + 0.55);
  }

  function thought() {
    if (!enabled || !gestureReceived) return;
    const ctx = ac(), now = ctx.currentTime;
    const osc = mkOsc(480), g = mkGain(0);
    osc.connect(g); g.connect(master);
    osc.start(now);
    g.gain.setValueAtTime(0, now);
    g.gain.linearRampToValueAtTime(0.055, now + 0.015);
    g.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
    osc.stop(now + 0.15);
  }

  function scuttle(spd) {
    if (!enabled || !gestureReceived || spd < 0.4) {
      if (scuttleT) { clearTimeout(scuttleT); scuttleT = null; }
      return;
    }
    if (scuttleT) return;
    const tick = () => {
      if (!enabled || !gestureReceived) { scuttleT = null; return; }
      const ctx = ac(), now = ctx.currentTime;
      // Triangle wave: warm, soft, organic — no metallic noise
      const freq = 280 + Math.random() * 220; // 280–500 Hz, varies per step
      const osc = mkOsc(freq, 'triangle'), g = mkGain(0);
      osc.connect(g); g.connect(master);
      osc.start(now);
      g.gain.setValueAtTime(0.055, now);
      g.gain.exponentialRampToValueAtTime(0.001, now + 0.028);
      osc.stop(now + 0.035);
      const delay = Math.max(60, 200 - spd * 55) + Math.random() * 25;
      scuttleT = setTimeout(tick, delay);
    };
    tick();
  }

  // ── Ambience helpers ─────────────────────────────────────────────────────
  function stopAmbience(fade = 1.5) {
    const s = [...ambiStoppers]; ambiStoppers = []; currentWorldId = null;
    s.forEach(fn => fn(fade));
  }

  function loopNoise(fType, freq, q, vol, fi = 2.5) {
    const n = mkNoise(), f = mkFilter(fType, freq, q), g = mkGain(0);
    n.connect(f); f.connect(g); g.connect(master); n.start();
    const now = ac().currentTime;
    g.gain.setValueAtTime(0, now);
    g.gain.linearRampToValueAtTime(vol, now + fi);
    return fade => {
      const t = ac().currentTime;
      g.gain.setValueAtTime(g.gain.value, t);
      g.gain.linearRampToValueAtTime(0, t + fade);
      setTimeout(() => n.stop(), (fade + 0.1) * 1000);
    };
  }

  function loopOsc(freq, type, vol, fi = 2.5, setup) {
    const osc = mkOsc(freq, type), g = mkGain(0);
    if (setup) setup(osc, g);
    osc.connect(g); g.connect(master); osc.start();
    const now = ac().currentTime;
    g.gain.setValueAtTime(0, now);
    g.gain.linearRampToValueAtTime(vol, now + fi);
    return fade => {
      const t = ac().currentTime;
      g.gain.setValueAtTime(g.gain.value, t);
      g.gain.linearRampToValueAtTime(0, t + fade);
      setTimeout(() => osc.stop(), (fade + 0.1) * 1000);
    };
  }

  function push(stopper) { ambiStoppers.push(stopper); }

  // ── World ambiences ──────────────────────────────────────────────────────
  function ambiObservatory() {
    // Cricket chorus — 4 detuned AM oscillators
    [3180, 3222, 3258, 3294].forEach((f, i) => {
      const osc = mkOsc(f), lfo = mkOsc(4.8 + i * 0.35), lfoG = mkGain(8), g = mkGain(0);
      lfo.connect(lfoG); lfoG.connect(osc.frequency);
      osc.connect(g); g.connect(master); osc.start(); lfo.start();
      const now = ac().currentTime;
      g.gain.setValueAtTime(0, now);
      g.gain.linearRampToValueAtTime(0.016, now + 3 + i * 0.4);
      push(fade => {
        const t = ac().currentTime;
        g.gain.setValueAtTime(g.gain.value, t);
        g.gain.linearRampToValueAtTime(0, t + fade);
        setTimeout(() => { osc.stop(); lfo.stop(); }, (fade + 0.1) * 1000);
      });
    });
    push(loopNoise('bandpass', 200, 0.45, 0.022, 4));
  }

  function ambiTokyo() {
    [[1100, 1.0, 0.10], [600, 0.5, 0.055], [3000, 1.8, 0.032]].forEach(([f, q, v]) => {
      push(loopNoise('bandpass', f, q, v, 2.5));
    });
    // Low city hum
    const osc = mkOsc(55, 'sawtooth'), filt = mkFilter('lowpass', 110, 0.6), g = mkGain(0);
    osc.connect(filt); filt.connect(g); g.connect(master); osc.start();
    const now = ac().currentTime;
    g.gain.setValueAtTime(0, now); g.gain.linearRampToValueAtTime(0.032, now + 4);
    push(fade => {
      const t = ac().currentTime;
      g.gain.setValueAtTime(g.gain.value, t); g.gain.linearRampToValueAtTime(0, t + fade);
      setTimeout(() => osc.stop(), (fade + 0.1) * 1000);
    });
  }

  function ambiAurora() {
    // Near-silent electromagnetic drone
    const osc = mkOsc(62), lfo = mkOsc(0.04), lfoG = mkGain(4), g = mkGain(0);
    lfo.connect(lfoG); lfoG.connect(osc.frequency);
    osc.connect(g); g.connect(master); osc.start(); lfo.start();
    const now = ac().currentTime;
    g.gain.setValueAtTime(0, now); g.gain.linearRampToValueAtTime(0.016, now + 6);
    push(fade => {
      const t = ac().currentTime;
      g.gain.setValueAtTime(g.gain.value, t); g.gain.linearRampToValueAtTime(0, t + fade);
      setTimeout(() => { osc.stop(); lfo.stop(); }, (fade + 0.1) * 1000);
    });
    // Rare wind puffs
    let windT;
    const windPuff = () => {
      if (currentWorldId !== 'northern-lights') return;
      const n = mkNoise(), nf = mkFilter('bandpass', 260, 0.4), ng = mkGain(0);
      n.connect(nf); nf.connect(ng); ng.connect(master); n.start();
      const now = ac().currentTime;
      ng.gain.setValueAtTime(0, now);
      ng.gain.linearRampToValueAtTime(0.038, now + 2);
      ng.gain.linearRampToValueAtTime(0, now + 5);
      n.stop(now + 5.5);
      windT = setTimeout(windPuff, 9000 + Math.random() * 14000);
    };
    windT = setTimeout(windPuff, 5000);
    push(() => clearTimeout(windT));
  }

  function ambiBioBay() {
    // Water with gentle lapping LFO
    const water = mkNoise(), wf = mkFilter('lowpass', 280, 0.7), wg = mkGain(0);
    const lapLfo = mkOsc(0.24), lapAmt = mkGain(0.018);
    water.connect(wf); wf.connect(wg); wg.connect(master);
    lapLfo.connect(lapAmt); lapAmt.connect(wg.gain);
    water.start(); lapLfo.start();
    const now = ac().currentTime;
    wg.gain.setValueAtTime(0, now); wg.gain.linearRampToValueAtTime(0.052, now + 3);
    push(fade => {
      const t = ac().currentTime;
      wg.gain.setValueAtTime(wg.gain.value, t); wg.gain.linearRampToValueAtTime(0, t + fade);
      setTimeout(() => { water.stop(); lapLfo.stop(); }, (fade + 0.1) * 1000);
    });
    // Tropical insects
    [4600, 5100, 5500, 5900, 6300].forEach((f, i) => {
      const osc = mkOsc(f), lfo = mkOsc(7 + i * 1.5), lfoG = mkGain(12), g = mkGain(0);
      lfo.connect(lfoG); lfoG.connect(osc.frequency);
      osc.connect(g); g.connect(master); osc.start(); lfo.start();
      const now = ac().currentTime;
      g.gain.setValueAtTime(0, now); g.gain.linearRampToValueAtTime(0.008, now + 2.5 + i * 0.35);
      push(fade => {
        const t = ac().currentTime;
        g.gain.setValueAtTime(g.gain.value, t); g.gain.linearRampToValueAtTime(0, t + fade);
        setTimeout(() => { osc.stop(); lfo.stop(); }, (fade + 0.1) * 1000);
      });
    });
  }

  function ambiAutumn() {
    push(loopNoise('bandpass', 380, 0.55, 0.038, 3));
    push(loopNoise('highpass', 2200, 0.35, 0.012, 4));
    // Generative birdsong — D major pentatonic
    const notes = [293, 329, 369, 440, 493, 587, 659, 880];
    let birdT;
    const chirp = () => {
      if (currentWorldId !== 'autumn-forest') return;
      const ctx = ac(), now = ctx.currentTime;
      const count = 2 + Math.floor(Math.random() * 3);
      for (let i = 0; i < count; i++) {
        const f = notes[Math.floor(Math.random() * notes.length)];
        const osc = mkOsc(f), g = mkGain(0);
        osc.connect(g); g.connect(master);
        const t = now + i * (0.07 + Math.random() * 0.13);
        osc.start(t);
        g.gain.setValueAtTime(0, t);
        g.gain.linearRampToValueAtTime(0.058, t + 0.01);
        g.gain.exponentialRampToValueAtTime(0.001, t + 0.16);
        osc.stop(t + 0.20);
      }
      birdT = setTimeout(chirp, 1600 + Math.random() * 4200);
    };
    birdT = setTimeout(chirp, 700);
    push(() => clearTimeout(birdT));
  }

  function ambiOcean() {
    // Pressure drone — ultra-low sine
    const drone = mkOsc(38), dg = mkGain(0);
    drone.connect(dg); dg.connect(master); drone.start();
    const now = ac().currentTime;
    dg.gain.setValueAtTime(0, now); dg.gain.linearRampToValueAtTime(0.058, now + 5);
    push(fade => {
      const t = ac().currentTime;
      dg.gain.setValueAtTime(dg.gain.value, t); dg.gain.linearRampToValueAtTime(0, t + fade);
      setTimeout(() => drone.stop(), (fade + 0.1) * 1000);
    });
    push(loopNoise('lowpass', 180, 0.5, 0.038, 4));
    // Whale song — FM synthesis
    let whaleT;
    const whale = () => {
      if (currentWorldId !== 'deep-ocean') return;
      const ctx = ac(), now = ctx.currentTime;
      const carrier = mkOsc(180), mod = mkOsc(2.5), modG = mkGain(75), g = mkGain(0);
      mod.connect(modG); modG.connect(carrier.frequency);
      carrier.connect(g); g.connect(master);
      carrier.start(now); mod.start(now);
      carrier.frequency.setValueAtTime(180, now);
      carrier.frequency.linearRampToValueAtTime(345, now + 2.5);
      carrier.frequency.linearRampToValueAtTime(210, now + 4.2);
      carrier.frequency.linearRampToValueAtTime(275, now + 5.8);
      carrier.frequency.linearRampToValueAtTime(135, now + 8.5);
      g.gain.setValueAtTime(0, now);
      g.gain.linearRampToValueAtTime(0.065, now + 0.9);
      g.gain.linearRampToValueAtTime(0.048, now + 4.2);
      g.gain.linearRampToValueAtTime(0.065, now + 5.8);
      g.gain.linearRampToValueAtTime(0, now + 9.5);
      carrier.stop(now + 10); mod.stop(now + 10);
      whaleT = setTimeout(whale, 22000 + Math.random() * 24000);
    };
    whaleT = setTimeout(whale, 4000 + Math.random() * 7000);
    push(() => clearTimeout(whaleT));
  }

  // ── Public ───────────────────────────────────────────────────────────────
  function _dispatch(worldId) {
    ({ observatory: ambiObservatory, 'tokyo-rain': ambiTokyo,
       'northern-lights': ambiAurora, 'bioluminescent-bay': ambiBioBay,
       'autumn-forest': ambiAutumn, 'deep-ocean': ambiOcean }
    )[worldId]?.();
  }

  function startAmbience(worldId) {
    if (!enabled) return;
    if (currentWorldId === worldId) return;
    stopAmbience(1.2);
    currentWorldId = worldId;
    if (!gestureReceived) { pendingWorldId = worldId; return; } // defer until gesture
    _dispatch(worldId);
  }

  function onGesture() {
    if (gestureReceived) return;
    gestureReceived = true;
    if (pendingWorldId && enabled) {
      const w = pendingWorldId; pendingWorldId = null;
      currentWorldId = null; // allow startAmbience to re-run
      startAmbience(w);
    }
  }

  function setEnabled(v) {
    enabled = v;
    localStorage.setItem('clawd-audio', v ? '1' : '0');
    if (!v) {
      stopAmbience(1.0);
      if (scuttleT) { clearTimeout(scuttleT); scuttleT = null; }
    } else {
      startAmbience(activeWorld?.id);
    }
  }

  function initEnabled(v) { enabled = v; }

  return { curious, happy, startled, thought, scuttle, startAmbience, setEnabled, initEnabled, onGesture,
           get enabled() { return enabled; } };
})();

// Audio button
const audioBtn = document.getElementById('audio-btn');
audioBtn.addEventListener('click', e => {
  e.stopPropagation();
  SFX.onGesture();
  SFX.setEnabled(!SFX.enabled);
  audioBtn.classList.toggle('on', SFX.enabled);
  audioBtn.title = SFX.enabled ? 'Mute sound' : 'Enable sound';
});

// Mark first user gesture so AudioContext can be safely created
document.addEventListener('pointerdown', SFX.onGesture);

// Restore audio preference across refreshes (just set the flag; loadWorld starts the ambience)
if (localStorage.getItem('clawd-audio') === '1') {
  SFX.initEnabled(true);
  audioBtn.classList.add('on');
  audioBtn.title = 'Mute sound';
}

// ── State machine ──────────────────────────────────────────────────────
const LABELS = {
  WANDER:'wandering', REST:'resting', CURIOUS:'curious',
  HAPPY:'happy', STARTLED:'startled'
};

function setState(s) {
  if (state === s) return;
  state = s; sTime = 0;
  hud.textContent = LABELS[s] || s;
  targetHue = HUE[s] ?? 270;
  if (s === 'CURIOUS')  SFX.curious();
  if (s === 'HAPPY')    SFX.happy();
  if (s === 'STARTLED') SFX.startled();
}

// ── Bubble ────────────────────────────────────────────────────────────
let bub = null, bubTO = null;

function say(text, ms = 2400) {
  if (!bub) { bub = Object.assign(document.createElement('div'), { className:'bubble' }); document.body.appendChild(bub); }
  clearTimeout(bubTO);
  bub.textContent = text;
  bub.classList.add('show');
  placeBub();
  SFX.thought();
  bubTO = setTimeout(() => bub?.classList.remove('show'), ms);
}

function placeBub() {
  if (!bub) return;
  const right = px + CW + 110 > innerWidth;
  bub.style.left = right ? (px - 8 - (bub.offsetWidth||80)) + 'px' : (px + CW + 14) + 'px';
  bub.style.top  = (py + 18) + 'px';
}

// ── Particles ──────────────────────────────────────────────────────────
function burst() {
  const glyphs = ['✦','★','♥','◆','✧','·','*','✱'];
  for (let i = 0; i < 7; i++) {
    setTimeout(() => {
      const p  = document.createElement('div');
      const a  = Math.random()*Math.PI*2;
      const d  = 30 + Math.random()*65;
      p.style.cssText = `position:fixed;pointer-events:none;z-index:50;
        font-family:VT323,monospace;font-size:16px;
        color:hsl(${currentHue},80%,72%);
        left:${cx()+(Math.random()-.5)*28}px;
        top:${cy()+(Math.random()-.5)*28}px;
        animation:fp 1.1s ease-out forwards;
        --tx:${(Math.cos(a)*d).toFixed(0)}px;
        --ty:${(Math.sin(a)*d-20).toFixed(0)}px;`;
      p.textContent = glyphs[Math.floor(Math.random()*glyphs.length)];
      document.body.appendChild(p);
      setTimeout(() => p.remove(), 1200);
    }, i*80);
  }
}

// ── Legs ───────────────────────────────────────────────────────────────
let legsOn = false;

function setLegs(on, dur = 0.35) {
  if (on === legsOn) return;
  legsOn = on;
  const anim = (name, d) => `${name} ${d}s infinite ease-in-out`;
  if (on) {
    leg1.style.animation = anim('scuttle-leg1', dur);
    leg2.style.animation = anim('scuttle-leg2', dur);
    leg3.style.animation = anim('scuttle-leg1', dur);
    leg4.style.animation = anim('scuttle-leg2', dur);
  } else {
    [leg1,leg2,leg3,leg4].forEach(l => l.style.animation = 'none');
  }
}

function setLegSpeed(dur) {
  if (!legsOn) return;
  [leg1,leg2,leg3,leg4].forEach(l => l.style.animationDuration = dur+'s');
}

// ── Eyes ───────────────────────────────────────────────────────────────
function updateEyes() {
  // Pupils: center at (15,16), (51,16) in SVG coords, can move ±1.3
  pupilL.setAttribute('x', Math.max(12, Math.min(15, 13.5 + lookX*1.3)));
  pupilR.setAttribute('x', Math.max(48, Math.min(51, 49.5 + lookX*1.3)));
  pupilL.setAttribute('y', Math.max(13.2, Math.min(17,  14.5 + lookY*1.2)));
  pupilR.setAttribute('y', Math.max(13.2, Math.min(17,  14.5 + lookY*1.2)));

  // Eyelids
  let lid = 0;
  if (blinking)          lid = 6.5;
  else if (state==='REST')     lid = 3.8;
  else if (state==='HAPPY')    lid = 1.8;
  eyelidL.setAttribute('height', lid);
  eyelidR.setAttribute('height', lid);

  // Blush
  const b = state==='HAPPY' ? (happiness*0.75).toFixed(2) : 0;
  blushL.setAttribute('opacity', b);
  blushR.setAttribute('opacity', b);
}

// ── Main update ────────────────────────────────────────────────────────
const MARGIN = 55, FRICT = 0.912;

function update(dt) {
  sTime += dt; wPhase += dt*3.8; bPhase += dt*1.1; wDirTimer += dt;

  const near = dist2mouse() < 195;

  // Hue interpolation (handles wraparound)
  let dh = targetHue - currentHue;
  if (dh > 180) dh -= 360; if (dh < -180) dh += 360;
  currentHue += dh * Math.min(dt*1.6, 1);
  setHue(currentHue);

  // Blink
  blinkTimer += dt;
  if (!blinking && blinkTimer >= nextBlink) {
    blinking = true; blinkTimer = 0;
    setTimeout(() => { blinking = false; nextBlink = 2.5 + Math.random()*6; }, 110);
  }

  // Look direction
  if (state==='CURIOUS' || state==='HAPPY') {
    const ddx = mx-cx(), ddy = my-cy(), dd = Math.hypot(ddx,ddy)||1;
    lookX += ((ddx/dd)*.9 - lookX) * dt*4;
    lookY += ((ddy/dd)*.7 - lookY) * dt*4;
  } else if (state==='STARTLED') {
    lookX += (-facing*.9 - lookX)*dt*5;
    lookY += (-0.5 - lookY)*dt*5;
  } else {
    const spd2 = Math.hypot(vx,vy);
    if (spd2 > .3) {
      lookX += ((vx/spd2)*facing - lookX)*dt*2.5;
      lookY += ((vy/spd2)*.4 - lookY)*dt*2.5;
    } else {
      lookX *= 1-dt*1.5; lookY *= 1-dt*1.5;
    }
  }

  // State machine
  switch (state) {
    case 'WANDER': {
      if (wDirTimer > 2+Math.random()*3) {
        wDirTimer = 0;
        const a = Math.atan2(wDirY,wDirX) + (Math.random()-.5)*1.5;
        wDirX = Math.cos(a); wDirY = Math.sin(a);
      }
      vx += wDirX*1.3*.09; vy += wDirY*1.3*.09;
      if (near) { curiousT += dt; if (curiousT>1.4) setState('CURIOUS'); }
      else curiousT = Math.max(0, curiousT-dt*.5);
      if (sTime>7 && Math.random()<.004) setState('REST');
      break;
    }
    case 'REST': {
      vx*=.85; vy*=.85;
      if (near && sTime>1) setState('CURIOUS');
      if (sTime > 4+Math.random()*5) {
        setState('WANDER');
        const a = Math.random()*Math.PI*2; wDirX = Math.cos(a); wDirY = Math.sin(a);
      }
      break;
    }
    case 'CURIOUS': {
      const ddx=mx-cx(), ddy=my-cy(), dd=Math.hypot(ddx,ddy)||1;
      if (dd>55) { vx+=(ddx/dd)*3*.17; vy+=(ddy/dd)*3*.17; }
      else {
        happiness = Math.min(1, happiness+dt*.9); vx*=.87; vy*=.87;
        if (happiness>.65 && sTime>.6) { setState('HAPPY'); burst(); say(['!!',':D','♥'][Math.floor(Math.random()*3)]); }
      }
      if (!near && sTime>2.5) { setState('WANDER'); curiousT=0; }
      break;
    }
    case 'HAPPY': {
      vx*=.91; vy*=.91;
      happiness = Math.max(0, happiness - dt*(near?.1:.28));
      if (happiness<.04) setState('WANDER');
      break;
    }
    case 'STARTLED': {
      if (sTime>1.4) { setState('WANDER'); const a=Math.atan2(vy,vx); wDirX=Math.cos(a); wDirY=Math.sin(a); }
      break;
    }
  }

  // Physics
  vx*=FRICT; vy*=FRICT;
  const spd = Math.hypot(vx,vy);
  const maxS = state==='STARTLED'?15 : state==='CURIOUS'?4 : 2.2;
  if (spd>maxS) { vx=vx/spd*maxS; vy=vy/spd*maxS; }
  px+=vx; py+=vy;

  // Walls
  const maxX = innerWidth-CW-MARGIN, maxY = innerHeight-CH-MARGIN;
  if (px<MARGIN)  { px=MARGIN;  vx= Math.abs(vx)*.6; wDirX= Math.abs(wDirX); }
  if (px>maxX)    { px=maxX;    vx=-Math.abs(vx)*.6; wDirX=-Math.abs(wDirX); }
  if (py<MARGIN)  { py=MARGIN;  vy= Math.abs(vy)*.6; wDirY= Math.abs(wDirY); }
  if (py>maxY)    { py=maxY;    vy=-Math.abs(vy)*.6; wDirY=-Math.abs(wDirY); }

  if (Math.abs(vx)>.15) facing = vx>0 ? 1 : -1;

  SFX.scuttle(spd);

  // Trail
  if (spd>.4) trail.push({ x:cx(), y:cy(), age:0 });
  for (const t of trail) t.age += dt;
  while (trail.length && trail[0].age > TRAIL_LIFE) trail.shift();

  // Legs
  if (state==='REST') {
    setLegs(false);
  } else {
    setLegs(spd>.4);
    if (spd>.4) setLegSpeed(Math.max(.1, .42-spd*.018));
  }

  // Visual transform
  let sx=facing, sy=1, rot=0, tx=0, ty=0;

  if ((state==='WANDER'||state==='CURIOUS') && spd>.3) {
    rot = Math.sin(wPhase)*3.5;
    ty  = -Math.abs(Math.sin(wPhase))*3;
  }
  if (state==='REST') {
    const b = Math.sin(bPhase)*.038; sy=1+b; sx*=(1-b*.3);
  }
  if (state==='HAPPY') {
    const w = Math.sin(wPhase*5)*.13*happiness;
    sx*=(1+w); sy=1-Math.abs(w)*.32;
    rot = Math.sin(wPhase*5)*9*happiness;
    ty  = -Math.abs(Math.sin(wPhase*5))*5*happiness;
  }
  if (state==='STARTLED') {
    const f = 1-sTime/1.4;
    tx = Math.sin(wPhase*16)*5*f;
    sx*=.87; sy=1.13;
  }

  wrap.style.left = px+'px'; wrap.style.top = py+'px';
  svgWrap.style.transform =
    `translate(${tx.toFixed(1)}px,${ty.toFixed(1)}px)`+
    ` scaleX(${sx.toFixed(3)}) scaleY(${sy.toFixed(3)})`+
    ` rotate(${rot.toFixed(1)}deg)`;

  updateEyes();
  placeBub();

  // Broadcast Clawd position to world
  try {
    if (worldFrame.contentWindow) {
      worldFrame.contentWindow.postMessage({
        type: 'clawd',
        cx: cx() / innerWidth,
        cy: cy() / innerHeight,
        state: state,
        speed: Math.hypot(vx, vy)
      }, '*');
    }
  } catch(e) {}
}

// ── Render trail ───────────────────────────────────────────────────────
function render() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  const wid = activeWorld?.id;
  for (const t of trail) {
    const a = (1 - t.age/TRAIL_LIFE) * 0.16;
    const r = 3.5 * (1 - t.age/TRAIL_LIFE) + .5;
    switch (wid) {
      case 'deep-ocean':
        ctx.strokeStyle = `hsla(180, 80%, 75%, ${a})`;
        ctx.lineWidth = 0.8;
        ctx.beginPath(); ctx.arc(t.x, t.y, r, 0, Math.PI*2); ctx.stroke();
        break;
      case 'bioluminescent-bay':
        ctx.fillStyle = `hsla(175, 80%, 65%, ${a * 1.4})`;
        ctx.beginPath(); ctx.arc(t.x, t.y, r * 1.3, 0, Math.PI*2); ctx.fill();
        break;
      case 'autumn-forest':
        ctx.fillStyle = `hsla(28, 85%, 60%, ${a})`;
        ctx.beginPath(); ctx.arc(t.x, t.y, r, 0, Math.PI*2); ctx.fill();
        break;
      case 'tokyo-rain':
        ctx.fillStyle = `hsla(215, 70%, 68%, ${a})`;
        ctx.fillRect(t.x - 0.5, t.y, 1, r * 4);
        break;
      case 'northern-lights':
        ctx.fillStyle = `hsla(140, 80%, 68%, ${a})`;
        ctx.beginPath(); ctx.arc(t.x, t.y, r * 1.2, 0, Math.PI*2); ctx.fill();
        break;
      default:
        ctx.fillStyle = `hsla(${currentHue}, 70%, 65%, ${a})`;
        ctx.beginPath(); ctx.arc(t.x, t.y, r, 0, Math.PI*2); ctx.fill();
        break;
    }
  }
}

// ── Input ──────────────────────────────────────────────────────────────
document.addEventListener('mousemove', e => {
  const dx = e.clientX-lmx, dy = e.clientY-lmy;
  mspeed = Math.hypot(dx,dy); lmx=e.clientX; lmy=e.clientY;
  mx=e.clientX; my=e.clientY;

  cursor.style.left = mx+'px'; cursor.style.top = my+'px';
  cursor.classList.toggle('near', dist2mouse()<160);

  if (mspeed>65 && dist2mouse()<165 && state!=='STARTLED') {
    const ddx=cx()-e.clientX, ddy=cy()-e.clientY, d=Math.hypot(ddx,ddy)||1;
    vx+=(ddx/d)*12; vy+=(ddy/d)*12;
    setState('STARTLED'); say('!!', 1500);
  }
});

document.addEventListener('click', e => {
  if (dist2mouse() < 120) {
    if (state==='HAPPY') {
      burst();
      say(['♥','!!','✦','yay','!!!!'][Math.floor(Math.random()*5)]);
    } else {
      const ddx=cx()-e.clientX, ddy=cy()-e.clientY, d=Math.hypot(ddx,ddy)||1;
      vx+=(ddx/d)*10; vy+=(ddy/d)*10;
      setState('STARTLED'); say('!!', 1500);
    }
  }
});

// ── Spontaneous thoughts ───────────────────────────────────────────────
const THOUGHTS = {
  WANDER:['...','~','•','..'], REST:['zzz','~','...','z'],
  CURIOUS:['?','!?','oh','hmm'], HAPPY:['♥','!!',':D','✦'],
  STARTLED:['!!','!','!!!'],
};
setInterval(() => {
  if (Math.random()<.35) {
    const opts = THOUGHTS[state]||['...'];
    say(opts[Math.floor(Math.random()*opts.length)], 1900);
  }
}, 8000);

// ── Loop ───────────────────────────────────────────────────────────────
let last = 0;
function loop(t) {
  const dt = Math.min((t-last)/1000, .05); last=t;
  if (dt>0) { update(dt); render(); }
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// ── World system ───────────────────────────────────────────────────────
const WORLDS = [
  {
    id: 'void',
    name: 'void',
    file: null,
    colors: ['#07070f', '#0e0a24', '#1a0f42'],
  },
  {
    id: 'observatory',
    name: 'Observatory · Twilight',
    file: 'worlds/observatory.html',
    colors: ['#03011a', '#2c1358', '#b83a14', '#dc6010'],
  },
  {
    id: 'tokyo-rain',
    name: 'Tokyo · 2am Rain',
    file: 'worlds/tokyo-rain.html',
    colors: ['#04030e', '#0c0a20', '#1a0818', '#cc1828'],
  },
  {
    id: 'northern-lights',
    name: 'Aurora · Iceland',
    file: 'worlds/northern-lights.html',
    colors: ['#010208', '#020d20', '#00c870', '#7030c8'],
  },
  {
    id: 'bioluminescent-bay',
    name: 'Bioluminescent Bay',
    file: 'worlds/bioluminescent-bay.html',
    colors: ['#020508', '#040e18', '#00e8f0', '#20e8b0'],
  },
  {
    id: 'autumn-forest',
    name: 'Autumn Dawn · Forest',
    file: 'worlds/autumn-forest.html',
    colors: ['#0c0418', '#5c1810', '#c04010', '#f08828'],
  },
  {
    id: 'deep-ocean',
    name: 'Abyssal · Deep Ocean',
    file: 'worlds/deep-ocean.html',
    colors: ['#000205', '#020510', '#00c8e0', '#d4e818'],
  },
  {
    id: 'volcanic-island',
    name: 'Volcanic · Island Night',
    file: 'worlds/volcanic-island.html',
    colors: ['#0a0402', '#1c0804', '#ff4010', '#ff8030'],
  },
];

const worldFrame  = document.getElementById('world-frame');
const worldsBtn   = document.getElementById('worlds-btn');
const worldsPanel = document.getElementById('worlds-panel');
const worldPicker = document.getElementById('world-picker');
let activeWorld   = WORLDS[0];

function buildPanel() {
  worldsPanel.innerHTML = '';
  WORLDS.forEach(w => {
    const opt = document.createElement('div');
    opt.className = 'world-option' + (w.id === activeWorld.id ? ' active' : '');

    const swatch = document.createElement('div');
    swatch.className = 'world-swatch';
    swatch.style.background = w.colors.length > 1
      ? `linear-gradient(90deg, ${w.colors.join(',')})`
      : w.colors[0];

    const name = document.createElement('span');
    name.textContent = w.name;

    opt.append(swatch, name);
    opt.addEventListener('click', () => loadWorld(w));
    worldsPanel.appendChild(opt);
  });
}

function loadWorld(w) {
  activeWorld = w;
  worldsPanel.classList.remove('open');
  worldFrame.classList.remove('loaded');

  setTimeout(() => {
    if (!w.file) {
      worldFrame.src = 'about:blank';
      document.body.classList.remove('world-active');
    } else {
      document.body.classList.add('world-active');
      worldFrame.src = w.file;
      worldFrame.onload = () => worldFrame.classList.add('loaded');
    }
  }, 400);

  buildPanel();
  SFX.startAmbience(w.id);
}

worldsBtn.addEventListener('click', e => {
  e.stopPropagation();
  worldsPanel.classList.toggle('open');
  if (worldsPanel.classList.contains('open')) buildPanel();
});

document.addEventListener('click', e => {
  if (!worldPicker.contains(e.target)) worldsPanel.classList.remove('open');
});

// Random world on every load (pick from non-void worlds)
const realWorlds = WORLDS.filter(w => w.file !== null);
loadWorld(realWorlds[Math.floor(Math.random() * realWorlds.length)]);
</script>
</body>
</html>
